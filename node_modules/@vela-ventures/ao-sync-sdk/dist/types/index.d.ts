import { IClientOptions } from "mqtt";
import type Transaction from "arweave/web/lib/transaction";
import type { PermissionType, GatewayConfig, DispatchResult, DataItem, AppInfo, UserTokensResult, UserTokensOptions } from "arconnect";
import "./fonts";
import { Contact, Wallet } from "./types";
declare global {
    interface Window {
        __AOSYNC_VERSION__?: string;
    }
}
export default class WalletClient {
    private client;
    uid: string | null;
    private qrCode;
    private modal;
    private approvalModal;
    private responseListeners;
    private connectionListener;
    private reconnectListener;
    private responseTimeoutMs;
    private txTimeoutMs;
    private eventListeners;
    private activeTimeouts;
    private isConnected;
    private reconnectionTimeout;
    private connectOptions;
    private browserWalletBackup;
    private pendingRequests;
    private isDarkMode;
    sessionActive: boolean;
    private isAppleMobileDevice;
    private isInappBrowser;
    private autoSign;
    constructor(responseTimeoutMs?: number, txTimeoutMs?: number);
    private createModal;
    private createApprovalModal;
    private handleMQTTMessage;
    private base64UrlDecode;
    private isVersionValid;
    private handleConnectResponse;
    private handleDisconnectResponse;
    private publishMessage;
    private createResponsePromise;
    private clearAllTimeouts;
    connect({ permissions, appInfo, gateway, brokerUrl, options, }: {
        permissions?: PermissionType[];
        appInfo?: AppInfo;
        gateway?: GatewayConfig;
        brokerUrl?: string;
        options?: IClientOptions;
    }): Promise<void>;
    reconnect(brokerUrl?: string, options?: IClientOptions): Promise<void>;
    private processPendingRequests;
    disconnect(): Promise<void>;
    getActiveAddress(): Promise<string>;
    getAllAddresses(): Promise<string[]>;
    getPermissions(): Promise<PermissionType[]>;
    getWalletNames(): Promise<{
        [addr: string]: string;
    }>;
    getWallets(): Promise<Wallet[]>;
    encrypt(data: BufferSource, algorithm?: RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<Uint8Array>;
    decrypt(data: BufferSource, algorithm?: RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<Uint8Array>;
    getArweaveConfig(): Promise<GatewayConfig>;
    signature(data: Uint8Array, algorithm?: AlgorithmIdentifier | RsaPssParams | EcdsaParams): Promise<Uint8Array>;
    getActivePublicKey(): Promise<string>;
    addToken(id: string): Promise<void>;
    sign(transaction: Transaction): Promise<Transaction>;
    dispatch(transaction: Transaction): Promise<DispatchResult>;
    signDataItem(dataItem: DataItem): Promise<ArrayBuffer>;
    isAvailable(): Promise<boolean>;
    on(event: string, listener: (data: any) => void): void;
    off(event: string, listener: (data: any) => void): void;
    private emit;
    userTokens(options?: UserTokensOptions): Promise<UserTokensResult>;
    swapActiveWallet(walletAddress: string): Promise<string>;
    getContacts(): Promise<Contact[]>;
    private populateWindowObject;
}
